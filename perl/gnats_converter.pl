#
# gnats_converter — Normalize mixed utf-8, ascii, iso8859-1 and windows-1252 data into utf-8
# © 2021 Phoenix Software International, MIT License
# vim: syntax=perl
#
# Parameter is expected to be a string of raw bytes containing mixed code set data.
# Returns a normalized string as utf-8 octets.
#
sub converter
{
  my @ascii_extended = (
    # windows-1252 only #
    [0xe2,0x82,0xac],[0xc2,0x81],[0xe2,0x80,0x9a],[0xc6,0x92],[0xe2,0x80,0x9e],[0xe2,0x80,0xa6],[0xe2,0x80,0xa0],[0xe2,0x80,0xa1],
    [0xcb,0x86],[0xe2,0x80,0xb0],[0xC5,0xA0],[0xe2,0x80,0xb9],[0xc5,0x92],[0xc2,0x8d],[0xc5,0xbd],[0xc2,0x8f],
    [0xc2,0x90],[0xe2,0x80,0x98],[0xe2,0x80,0x99],[0xe2,0x80,0x9c],[0xe2,0x80,0x9d],[0xe2,0x80,0xa2],[0xe2,0x80,0x93],[0xe2,0x80,0x94],
    [0xcb,0x9c],[0xe2,0x84,0xa2],[0xc5,0xa1],[0xe2,0x80,0xba],[0xc5,0x93],[0xc2,0x9d],[0xc5,0xbe],[0xc5,0xb8],
    # iso8859-1 and windows-1252 #
    [0xc2,0xa0],[0xc2,0xa1],[0xc2,0xa2],[0xc2,0xa3],[0xc2,0xa4],[0xc2,0xa5],[0xc2,0xa6],[0xc2,0xa7],
    [0xc2,0xa8],[0xc2,0xa9],[0xc2,0xaa],[0xc2,0xab],[0xc2,0xac],[0xc2,0xad],[0xc2,0xae],[0xc2,0xaf],
    [0xc2,0xb0],[0xc2,0xb1],[0xc2,0xb2],[0xc2,0xb3],[0xc2,0xb4],[0xc2,0xb5],[0xc2,0xb6],[0xc2,0xb7],
    [0xc2,0xb8],[0xc2,0xb9],[0xc2,0xba],[0xc2,0xbb],[0xc2,0xbc],[0xc2,0xbd],[0xc2,0xbe],[0xc2,0xbf],
    [0xc3,0x80],[0xc3,0x81],[0xc3,0x82],[0xc3,0x83],[0xc3,0x84],[0xc3,0x85],[0xc3,0x86],[0xc3,0x87],
    [0xc3,0x88],[0xc3,0x89],[0xc3,0x8a],[0xc3,0x8b],[0xc3,0x8c],[0xc3,0x8d],[0xc3,0x8e],[0xc3,0x8f],
    [0xc3,0x90],[0xc3,0x91],[0xc3,0x92],[0xc3,0x93],[0xc3,0x94],[0xc3,0x95],[0xc3,0x96],[0xc3,0x97],
    [0xc3,0x98],[0xc3,0x99],[0xc3,0x9a],[0xc3,0x9b],[0xc3,0x9c],[0xc3,0x9d],[0xc3,0x9e],[0xc3,0x9f],
    [0xc3,0xa0],[0xc3,0xa1],[0xc3,0xa2],[0xc3,0xa3],[0xc3,0xa4],[0xc3,0xa5],[0xc3,0xa6],[0xc3,0xa7],
    [0xc3,0xa8],[0xc3,0xa9],[0xc3,0xaa],[0xc3,0xab],[0xc3,0xac],[0xc3,0xad],[0xc3,0xae],[0xc3,0xaf],
    [0xc3,0xb0],[0xc3,0xb1],[0xc3,0xb2],[0xc3,0xb3],[0xc3,0xb4],[0xc3,0xb5],[0xc3,0xb6],[0xc3,0xb7],
    [0xc3,0xb8],[0xc3,0xb9],[0xc3,0xba],[0xc3,0xbb],[0xc3,0xbc],[0xc3,0xbd],[0xc3,0xbe],[0xc3,0xbf]
    );

  my @raw = unpack( "C*" );
  my $k = 0;
  my $len = @raw;
  my @buffer = ();

  for ( my $i = 0 ; $i < $len ; $i++ ) {
    my $n = $raw[$i];
    if ( ! ($n < 128) ) {
      if ( $i > $k ) {
        push @buffer, (@raw[$k...$i-1]);
      }
      if ( (($n & 0xe0) == 0xc0) && ($i + 1 < $len) && (($raw[$i+1] & 0xc0) == 0x80) ) {
        push @buffer, (@raw[$i...$i+1]);
        $i += 1;
        $k = $i + 1;
      }
      elsif ( (($n & 0xf0) == 0xe0) && ($i + 2 < $len) && (($raw[$i+1] & 0xc0) == 0x80) && (($raw[$i+2] & 0xc0) == 0x80) ) {
        push @buffer, (@raw[$i...$i+2]);
        $i += 2;
        $k = $i + 1;
      }
      elsif ( (($n & 0xf8) == 0xf0) && ($i + 3 < $len) && (($raw[$i+1] & 0xc0) == 0x80) && (($raw[$i+2] & 0xc0) == 0x80) && (($raw[$i+3] & 0xc0) == 0x80) ) {
        push @buffer, (@raw[$i...$i+3]);
        $i += 3;
        $k = $i + 1;
      }
      else {
        push @buffer, @{$ascii_extended[$n-128]};
        $k = $i + 1;
      }
    }
  }
  if ( $k < $len ) {
    push @buffer, @raw[$k...$len-1];
  }

  return pack( "C*", @buffer );
}
